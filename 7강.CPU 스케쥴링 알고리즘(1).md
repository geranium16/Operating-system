# [운영체제] 7.CPU스케쥴링 알고리즘(1)

> CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이 때 다음 프로세스를 무엇을 실행할지선택하는 알고리즘을 **CPU Scheduling 알고리즘**이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없으며 상황마다 효율적인 여러 방법이 있다.



## 1. Preemptive vs Non-preemptive

### 1.1. Preemptive

 Preemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 **CPU를 강제로 점유** 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다.

### 1.2. Non-preemptive

 Non-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다.



### 1. 3. Scheduling criteria

Scheduling criteria(척도)는 스케줄링의 효율(성능)을 분석하는 기준들이다.

- CPU Utilization (CPU 이용률,%) : CPU가 얼마나 놀지 않는지

- Throughput (처리율,jobs/sec) : 단위시간당 처리하는 작업의 수(처리량)

- Turnaround time (반환시간) : 프로세스의 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.)

  ex) 병원에서 입장해서(시작) 접수하고 뭐하고 진료받고 기다리고 엑스레이 찍고 다시 대기실로갔다가 의사쌤만나고.... 나간다.(종료)

- Waiting time (대기시간): CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외)

- Response time (응답시간): 첫응답이 나올때까지 걸리는 시간? (대화형 컴퓨터에서 )

  

## 2. CPU Scheduling Algorithm

> - First-Come, First-Served (FCFS)
>
> - Shortest-Job-First (SJF)
>
> - Shortest-Remaining-Time-First
>
> - Priority
>
> - Round-Robin (RR)
>
> - Multilevel Queue
>
> - Multilevel Feedback Queue1.2. 프로세스 상태



### 1.1. First-Come, First-Served(FCFS)

FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다. (간단 & 공평)

- P1,P2,P3 순서대로 온 경우

#### Gantt Chart

| Process | Burst Time(msec) |
| ------- | ---------------- |
| P1      | 24               |
| P2      | 3                |
| P3      | 3                |

![img](https://user-images.githubusercontent.com/34755287/53879661-5d666b80-4052-11e9-8453-bad918a563ef.png)



 첫 번째 표는 3개의 프로세스와 각 프로세스가 CPU를 사용한 시간(burst time)을 나타낸다. 이를 간트 차트로 표현하면 표 아래의 그림과 같다.(도착시간은 모두 0초라고 가정한다.) 평균 대기시간을 계산하면 아래와 같다.

- Average Waiting Time = $\frac{0 + 24 + 27}{3} = 17msec$

만약, 프로세스가 들어온 순서가 `P3, P2, P1` 이라면 간트 차트는 아래 그림과 같이 바뀔 것이다.

![img](https://user-images.githubusercontent.com/34755287/53879665-5d666b80-4052-11e9-8ad5-8639b73b13ac.png)

- Average Waiting Time = $\frac{6 + 3 + 0}{3} = 3msec$

두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다.

위 예제처럼 `P1, P2, P3` 순서로 들어온 것을 **Convoy Effect** 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다. P1이 수행되는 동안 P2, P3는 오래 기다려야 하는 예제에서 이를 볼 수 있다. 이는 FCFS의 단점 중 하나이다. 그리고 FCFS는 **Non-preemptive** 이다. 하나의 프로세스가 끝나기 전에는 다른 프로세스가 중간에 끼어들 수 없다.

