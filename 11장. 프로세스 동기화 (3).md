# [운영체제] 10. 프로세스 동기화 (3)

### Dining Philosopher Problem

식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.

![img](https://user-images.githubusercontent.com/34755287/54337394-1f7ccf00-4672-11e9-9fc0-cb98c4171239.png)

이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 **한 명**뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다.

이를 자바 코드로 구현하면 아래와 같다.

```java
import java.util.concurrent.Semaphore;

class Philosopher extends Thread {
	int id; // philosopher id
	Semaphore lstick, rstick; // left, right chopsticks
	Philosopher(int id, Semaphore lstick, Semaphore rstick) {
		this.id = id;
		this.lstick = lstick;
		this.rstick = rstick;
	}

	public void run() {
		try {
			while (true) {
				lstick.acquire();
				rstick.acquire();
				eating();
				lstick.release();
				rstick.release();
				thinking();
			}
		}catch (InterruptedException e) { }
	}

	void eating() {
		System.out.println("[" + id + "] eating");
	}

	void thinking() {
		System.out.println("[" + id + "] thinking");
	}
}

class Test {
	static final int num = 5; // number of philosphers & chopsticks
	public static void main(String[] args) {
        int i;
        /* chopsticks */
        Semaphore[] stick = new Semaphore[num];
        for (i=0; i<num; i++)
            stick[i] = new Semaphore(1);
        /* philosophers */
        Philosopher[] phil = new Philosopher[num];
        for (i=0; i<num; i++)
            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);
        /* let philosophers eat and think */
        for (i=0; i<num; i++)
            phil[i].start();
      }
}
```

5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다.

단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.
이는 대표적인 **starvation** 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.

이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 즉, 모두가 lstick.acquire(); 까지 실행한 상태이다. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다.

이러한 상황을 **교착상태(deadlock)** 라고 한다.



## 1. Deadlock(교착상태)

프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.

즉, 다음과 같이 3가지 프로세스가 있다.

1프로세스 : A자원 B자원 요구   

2프로세스 : B자원 C자원 요구

3프로세스 : C자원, A자원 요구

이러한 프로세스가 있을 때 각각 A자원, B자원, C자원을 할당받은 상태에서 나머지 자원을 요구한다. 이 때 모두 사용하기 때문에 모두 대기상태에 빠진다. 이러한 상황을 교착상태라고 한다.

### 1.1. 교착상태 필요 조건(Necessary Conditions)

교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 **필요 조건**이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니고, 일어날 확률이 생기는 것이다.

- **Mutual exclusion (상호배타)**: 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
  \- 젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.
- **Hold and wait (보유 및 대기)**: 한 프로세스가 자원을 가지고 있는 상태에서 대기한다.
  \- 철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.
- **No Preemption (비선점)**: 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
  \- 한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.
- **Circular wait (환형대기)**: 프로세스가 요구하는 자원의 방향이 원형을 이룬다.
  \- 모든 철학자는 왼쪽 젓가락부터 집을 수 있다.

교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 **치명적**이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.

### 1.2. 자원(Resources)

하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다.

자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 **요청(request)**하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 **사용(use)**하고 모든 사용이 끝나면 이를 **반납(release)**한다.

#### 1.2.1 자원 할당도(Resource Allocation Graph)

자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 **그림**으로 나타낸 것이다.

- 자원: 사각형
- instance: 점
- 프로세스: 원
- 할당: 화살표

![img](https://user-images.githubusercontent.com/34755287/54337395-1f7ccf00-4672-11e9-8553-eeeb75b665a2.png)

위 그림을 보면 R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다

![img](https://user-images.githubusercontent.com/34755287/54337396-1f7ccf00-4672-11e9-87cf-aad98e2795fe.png)

자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 **mutual exclusion과 no-preemption은 기본으로 적용**된다.

Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.

Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.

![img](https://user-images.githubusercontent.com/34755287/54337397-1f7ccf00-4672-11e9-8386-698a4db14e43.png)

위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.

그러면 위에서 살펴본 식사하는 철학자 문제를 해결하기 위해 Circular wait 조건을 없애보자. (다른 여러 가지 방법이 존재한다.) Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.

![img](https://user-images.githubusercontent.com/34755287/54337399-20156580-4672-11e9-9b44-a784e582ba54.png)

위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.

```java
// Philosopher Thread run function
public void run() {
    try {
        while (true) {
            if (id % 2 == 0) {
                lstick.acquire();
                rstick.acquire();
            }
            else {
                rstick.acquire();
                lstick.acquire();
            }
            eating();
            lstick.release();
            rstick.release();
            thinking();
        }
    }catch (InterruptedException e) { }
}
```

위 코드는 철학자 쓰레드의 `run()` 함수에서 젓가락을 집는 코드를 바꾼 모습이다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.

## Reference

- [운영체제 KOCW 양희재 교수님 강의](http://www.kocw.net/home/cview.do?lid=985268d881a7defe)

- [Operation System Concepts 9th](http://www.kyobobook.co.kr/product/detailViewEng.laf?ejkGb=ENG&mallGb=ENG&barcode=9781118093757&orderClick=LAG&Kc=)

-  [SUNGBUM PARK 블로그](https://velog.io/@codemcd/운영체제OS-10.-프로세스-동기화-3)



