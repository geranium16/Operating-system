# [운영체제] 10. 프로세스 동기화 (3)

### Dining Philosopher Problem

식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.

![img](https://user-images.githubusercontent.com/34755287/54337394-1f7ccf00-4672-11e9-9fc0-cb98c4171239.png)

이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 **한 명**뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다.

이를 자바 코드로 구현하면 아래와 같다.

```java
import java.util.concurrent.Semaphore;

class Philosopher extends Thread {
	int id; // philosopher id
	Semaphore lstick, rstick; // left, right chopsticks
	Philosopher(int id, Semaphore lstick, Semaphore rstick) {
		this.id = id;
		this.lstick = lstick;
		this.rstick = rstick;
	}

	public void run() {
		try {
			while (true) {
				lstick.acquire();
				rstick.acquire();
				eating();
				lstick.release();
				rstick.release();
				thinking();
			}
		}catch (InterruptedException e) { }
	}

	void eating() {
		System.out.println("[" + id + "] eating");
	}

	void thinking() {
		System.out.println("[" + id + "] thinking");
	}
}

class Test {
	static final int num = 5; // number of philosphers & chopsticks
	public static void main(String[] args) {
        int i;
        /* chopsticks */
        Semaphore[] stick = new Semaphore[num];
        for (i=0; i<num; i++)
            stick[i] = new Semaphore(1);
        /* philosophers */
        Philosopher[] phil = new Philosopher[num];
        for (i=0; i<num; i++)
            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);
        /* let philosophers eat and think */
        for (i=0; i<num; i++)
            phil[i].start();
      }
}
```

5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다.

단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.
이는 대표적인 **starvation** 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.

이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 즉, 모두가 lstick.acquire(); 까지 실행한 상태이다. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다.

이러한 상황을 **교착상태(deadlock)** 라고 한다.



## 1. Deadlock(교착상태)

프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.

즉, 다음과 같이 3가지 프로세스가 있다.

1프로세스 : A자원 B자원 요구   

2프로세스 : B자원 C자원 요구

3프로세스 : C자원, A자원 요구

이러한 프로세스가 있을 때 각각 A자원, B자원, C자원을 할당받은 상태에서 나머지 자원을 요구한다. 이 때 모두 사용하기 때문에 모두 대기상태에 빠진다. 이러한 상황을 교착상태라고 한다.

### 1.1. 교착상태 필요 조건(Necessary Conditions)

교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 **필요 조건**이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니고, 일어날 확률이 생기는 것이다.

- **Mutual exclusion (상호배타)**: 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
  \- 젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.
- **Hold and wait (보유 및 대기)**: 한 프로세스가 자원을 가지고 있는 상태에서 대기한다.
  \- 철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.
- **No Preemption (비선점)**: 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
  \- 한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.
- **Circular wait (환형대기)**: 프로세스가 요구하는 자원의 방향이 원형을 이룬다.
  \- 모든 철학자는 왼쪽 젓가락부터 집을 수 있다.

교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 **치명적**이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.

### 1.2. 자원(Resources)

하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다.

자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 **요청(request)**하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 **사용(use)**하고 모든 사용이 끝나면 이를 **반납(release)**한다.

#### 1.2.1 자원 할당도(Resource Allocation Graph)

자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 **그림**으로 나타낸 것이다.

- 자원: 사각형
- instance: 점
- 프로세스: 원
- 할당: 화살표

![img](https://user-images.githubusercontent.com/34755287/54337395-1f7ccf00-4672-11e9-8553-eeeb75b665a2.png)

위 그림을 보면 R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다

![img](https://user-images.githubusercontent.com/34755287/54337396-1f7ccf00-4672-11e9-87cf-aad98e2795fe.png)

자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 **mutual exclusion과 no-preemption은 기본으로 적용**된다.

Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.

Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.

![img](https://user-images.githubusercontent.com/34755287/54337397-1f7ccf00-4672-11e9-8386-698a4db14e43.png)

위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.

그러면 위에서 살펴본 식사하는 철학자 문제를 해결하기 위해 Circular wait 조건을 없애보자. (다른 여러 가지 방법이 존재한다.) Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.

![img](https://user-images.githubusercontent.com/34755287/54337399-20156580-4672-11e9-9b44-a784e582ba54.png)

위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.

```java
// Philosopher Thread run function
public void run() {
    try {
        while (true) {
            if (id % 2 == 0) {
                lstick.acquire();
                rstick.acquire();
            }
            else {
                rstick.acquire();
                lstick.acquire();
            }
            eating();
            lstick.release();
            rstick.release();
            thinking();
        }
    }catch (InterruptedException e) { }
}
```

위 코드는 철학자 쓰레드의 `run()` 함수에서 젓가락을 집는 코드를 바꾼 모습이다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.



### 1.3. 교착상태 처리

#### 1.3.1. 교착상태 방지 (Deadlock Prevention)

교착상태 방지는 위에서 살펴본 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.

- **상호배타(Mutual exclusion)**: 상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 **불가능**한 경우가 많다.
- **보유 및 대기(Hold & Wait)**: 이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 **활용률을 저하시키고, starvation 현상이 발생하는 단점**이 있다. 필요한 자원 중 최소 하나가 계속 다른 프로세스에게 할당되어 있으면 이 프로세스는 무한정 대기해야 할 가능성이 생기게 된다.

​             예를 들어 P1은 A,B가 필요하고 P2=C,D가 필요하고 P3=A,C,D가 필요하다. 이 때 P1이 할당받으면 P2는 할당받			     을 수 있다. 이 때 A,B의 종료 시점이 엇갈릴 경우  P3는 계속 실행되지 못한다.

- **비선점(No preemption)**: 비선점을 없애려면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 **불가능**한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.

- **환형대기(Circular wait)**: 이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 **오름차순**으로 자원을 요청하는 것이다. 이 역시 **자원의 활용률을 저하**시키는 단점이 있다.

  ​	식사문제에서도 적용 가능 (마지막 프로세스의 양쪽은 5,0이 된다. 이를 통해 마지막이 순서가 바껴서 환형이 안들어 난다.)



네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold & wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태를 사전에 방지하는 것은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다.



#### 1.3.2. 교착상태 회피 (Deadlock Avoidance)

교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 **자원 요청에 대한 잘못된 승인**으로 판단한다. 교착상태의 방지는 교착상태 네가지 조건 중 하나를 깨서 교착상태가 발생한는 것을 방지하는 반면 교착상태의 회피는 운영체제가 자원할당을 잘못해줬다고 생각하는 것이다. 

따라서, 교착상태 회피에서는 **안전한 할당(Safe allocation)**과 **불안정한 할당(Unsafe allocation)** 두 가지로 나뉜다. 먼저 안전한 할당에 대한 예제를 보자.

#### 안전한 할당

현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.

| Process | Max needs | Current needs |
| ------- | --------- | ------------- |
| P0      | 10        | 5             |
| P1      | 4         | 2             |
| P2      | 9         | 2             |

3개의 프로세스가 요청하는 magnetic tape의 양은 위 표와 같다. Current needs는 한 프로세스가 한 번 요청을 할 때 요구하는 개수이고, Max needs는 프로세스를 정상적으로 끝내기 위해 필요한 총 개수이다. 운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.

- P0에게 5개를 할당한다.(5/10) => 현재 magnetic tape 개수: 7
- P1에게 2개를 할당한다.(2/4) => 현재 magnetic tape 개수: 5
- P2에게 2개를 할당한다.(2/9) => 현재 magnetic tape 개수: 3
- 다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.
- P1에게 2개를 할당한다.(4/4) => 현재 magnetic tape 개수: 1
- P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. => 현재 magnetic tape 개수: 5
- 대기하고 있던 P0에게 5개를 할당한다.(10/10) => 현재 magnetic tape 개수: 0
- P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. => 현재 magnetic tape 개수: 10
- P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다.

이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.

#### 불안전한 할당

| Process | Max needs | Current needs |
| ------- | --------- | ------------- |
| P0      | 10        | 5             |
| P1      | 4         | 2             |
| P2      | 9         | 3             |

이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.

- P0에게 5개를 할당한다.(5/10) => 현재 magnetic tape 개수: 7
- P1에게 2개를 할당한다.(2/4) => 현재 magnetic tape 개수: 5
- P2에게 3개를 할당한다.(3/9) => 현재 magnetic tape 개수: 2
- 다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.
- P1에게 2개를 할당한다.(4/4) => 현재 magnetic tape 개수: 0
- P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. => 현재 magnetic tape 개수: 4
- 대기하고 있던 P0는 아직 할당받으르 수 없다.
- P2에게 3개를 할당한다.(6/9) => 현재 magnetic tape 개수: 1
- 현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다.

이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 **불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.**

따라서 똑같은 상황에서도 자원 할당을 어떻게 해주느냐에 따라 데드락이 발생하기도 안하기도 한다.

교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 **Banker's Algorithm**이라 한다.

***자세히X 결과: Banker's Algorithm을 사용해서 불안전한 할당이 안발생하게 한다.***

#### 1.3.3. 교착상태 검출 및 복구 (Deadlock Detection & Recovery)

1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.

교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 **주기적으로 교착상태가 발생하였는지 검사**해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다.

복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.

교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다. 하지만 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.

#### 1.3.4. 교착상태 무시

교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다.

## Reference

- [운영체제 KOCW 양희재 교수님 강의](http://www.kocw.net/home/cview.do?lid=985268d881a7defe)

- [Operation System Concepts 9th](http://www.kyobobook.co.kr/product/detailViewEng.laf?ejkGb=ENG&mallGb=ENG&barcode=9781118093757&orderClick=LAG&Kc=)

-  [SUNGBUM PARK 블로그](https://velog.io/@codemcd/운영체제OS-10.-프로세스-동기화-3)



