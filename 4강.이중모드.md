





# [운영체제 4장] -이중 모드 및 하드웨어 보호 -

> ***: 운영체제의 기능 중 하나로, 일반 유저가 특별한 명령을 내리는 것을 막기 위해, 크게 I/O, 메모리, CPU를 보호하기 위해 이중 모드를 사용한다. 이 모드를 통해 커널모드를 하드웨어 접근이 가능하다. 즉,유저모드와 커널모드의 가장 큰 차이점은 접근 가능한 가상메모리의 범위이다.***
>
> 컴퓨터를 사용하는 환경은 다양하다. 특정 사람이 특정 컴퓨터만 사용하는 경우도 있겠지만 여러 사람이 동시에 사용하거나 한 사람이 여러 개의 프로그램을 동시에 실행하는 경우 한사람의 고의 또는 실수로 다른 프로그램 전체가 영향을 받을 수 있는 환경이 만들어진다. 예를 들면 **많은 사용자들이 같은 컴퓨터를 사용하고 있는데  서버에 stop(컴퓨터 강제 종료) 명령어 실행하는 프로그램을 갑자기 실행시키면 모든 사용자가 하던 작업이 종료되어 큰 영향을 끼칠 수 있다.** 이를 막기 위한 보호 장치가 바로 이중 모드다. 이중 모드는 사용자 모드와 커널 모두로 두 가지 모드를 가지고 있다. **사용자 모드는 단순한 사용자 프로그램을 작동시키는 반면 커널 모드는 시스템이 내리는 명령어, 프로그램 작동 명령어등 특권 명령어를 내릴 수 있다.**
>
> - 레지스터에 모드를 나타내는 플래그
>- 운영체제 서비스 실행될 때는 관리자 모드
> - 사용자 프로그램 실행될 때는 사용자 모드
>- 하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드
> - 운영체제 서비가 끝나면 다시 사용자 모드

> ****



### *레지스터

컴퓨터는 레지스터 단위로 정보를 주고 받는다. 

레지스터: 비트들의 모음 : 32비트컴퓨터 = 1레지스터에 32개비트

기본 데이터비트 + flag비트  

flag비트: carry(한자리 올라감), negative(음수) 등등….....

 여기에 **모드를 나타내는 플래그가 존재**하는데 0과 1을 값을 통해 사용자 모드(0)인지 커널 모드(1)인지를 판단한다. 운영체제 서비스가 실행될 때나 하드웨어/소프트웨어 인터럽트가 발생하는 때인 시스템 관련 환경에서는 커널 모드이고 사용자 프로그램을 실행하는 경우에는 사용자 모드로 존재한다.

### 명령어의 종류

CPU가 수행하는 명령에는 `일반 명령`과 `특권 명령`이 있다.
**일반 명령**은 메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령이고 모든 프로그램이 수행할 수 있는 명령이다.
**특권 명령**은 보안이 필요한 명령으로 입출력 장치, 타이머 등의 장치를 접근하는 명령이다. 특권 명령은 항상 `운영체제`만이 수행할 수 있다.

### kernel mode vs user mode

**kernel mode**는 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드로 `일반 명령`과 `특권 명령` 모두 수행할 수 있다.
**user mode**는 일반 사용자 프로그램이 CPU제어권을 가지고 명령을 수행하는 모드이기 때문에 `일반 명령`만을 수행할 수 있다.

**즉, user mode: 유저프로그램이 CPU씀 + user mode이므로 제한된 동작은 못함. 필요하면 sys call 호출, **

***kernel mode: sys call에 의해 OS가 CPU씀(제어권 가져옴) kernel mode이므로 제한된 동작 가능***

### 과정을 살펴보자

위의 process A가 프로그램 명령 수행중에 디스크 입출력 명령을 읽은 경우를 생각해 보자. 사용자 프로그램은 입출력 장치에 접근하는 명령을 수행할 수 없다. user mode에서 특권 명령을 수행할 수 없기 때문이다.
이련 경우에 사용자 프로그램은 운영체제에게 `시스템 콜`을 통해 특권명령을 대신 수행해달라고 요청한다. 시스템 콜은 주소 공간 자체가 다른 곳(커널의 code영역)으로 이동해야 하므로 **프로그램이 인터럽트 라인에 인터럽트를 세팅**하는 명령을 통해 이루어진다.

> 사용자 프로세스가 소프트웨어 인터럽트를 통해 커널의 기능을 이용하기 위해 서비스를 요청하는 하나의 방법이다. 즉, 인터럽트의 한 종류이다.

CPU가 인터럽트 라인을 검사하고 인터럽트가 발생한 것을 감지하게 된다. 현재 수행중인 사용자 프로그램을 잠시 멈추고 CPU의 제어권을 운영체제에게 양도한다. (kernel mode) 그리고 이 때 하드웨어적으로 `모드 비트`가 1에서 0으로 자동으로 세팅되어 특권 명령을 수행할 수 있게 된다.

![image.png](https://img.velog.io/post-images/adam2/77e17e20-2fc9-11ea-a15f-818085aba1cd/image.png?w=1024)





***즉, 하나의 프로그램 실행-> 유저프로그램이 실행되다가 특권명령 발생 -> 인터럽트 발생하여 시스템모드 -> 이 처리가 끝나면 다시 유저 프로그램 -> 시스템모드 ->유저모드 ->시스템모드 반복…***

<img src="/Users/DaeHyeon/Library/Application Support/typora-user-images/스크린샷 2020-02-26 오후 8.04.22.png" alt="스크린샷 2020-02-26 오후 8.04.22" style="zoom:50%;" />

*** *만약, 일반 유저가 특권 명령을 내리면?(고의로)***

 ***cpu가 이 명령을 읽고 모니터비트가 0인지 1인지 확인하여 모니터비트가 0인 경우 잘못된 명령이라 생각하고 내부 인터럽트가 발생시켜 이 특권 명령을 수행하는 대신 미리 올려진 ISR이 실행되며 특권 명령은 사라진다.***





이중 보호는 하드웨어 보호에 큰 역할을 담당하는데 입출력 장치 보호, 메모리 보호, CPU 보호 이렇게 세 가지로 나눌 수 있다.

1. 입출력 장치 보호 (Input/Output device protection)
2. 메모리 보호 (Memory protection)
3. CPU 보호 (CPU protection)



### 입출력 장치 보호 (Input/Output device protection)

 사용자의 잘못된 입출력 명령어를 제어한다. 다른 사용자와 동시 사용하는 것을 막기 위해 입출력 명령을 특권 명령어로 하여 IN, OUT 이라는 명령어가 존재한다. 입출력 장치를 사용하기 위해서는 운영체제에 입출력을 하고 싶다는 것을 요청하고 커널 모드로 운영체제가 입출력을 실행시켜주면 일이 끝난 후 사용자 모드로 돌아오게 된다. 만약 다른 사용자가 사용할 경우 올바른 요청이 아니므로 운영체제가 거부를 하게 된다.

- **다른 사용자의 입출력,정보등에 방해 (프린트 혼선, 리셋등)**

  - 1번 사용자가 프린트하고 있는데 2번 사용자가 프린트하려고 하는 경우

  -  A가 사용하는 하드디스크파일이 있는데 B가 읽으려고 하는 경우



- **해결법**

  - 입출력 명령을 특권명령으로 IN,OUT

  - 입출력을 하려면 운영체제에게 요청하고 (System mode 전환)

  - 운영체제가 입출력 대행; 마친 후 다시 user mode복귀

  - 올바른 요청이 아니면 운영체제가 거부

    

 게임 중(유저모드) IN,OUT명령 불가능하게 되고 IN,OUT을 하려면 소프트웨어인터럽트에 의해(INT명령) OS에 부탁해 SystemMode로 변경  후 OS에서 이에 해당하는 ISR 실행 (사용자 -> OS ->사용자)

*** *Privileged Instruction vilolation***



### 메모리 보호 (Memory protection)

 메모리 보호를 위한 역할은 다른 사용자가 메모리 또는 운영체제 영역 메모리를 접근할 경우를 막기 위한 작업이다. 특히 해킹에 관련된 부분이 많이 작용을 한다. 이를 제어하기 위해 **MMU(Memory Management Unit)**를 두어 다른 메모리 영역 침범하는 것을 감시하는 장치를 놓는다. MMU는 각 사용자마다 할당 받을 수 있는 메모리 공간의 영역을 정하여 다른 사용자는 침범을 할 수 없게 만든다. 이러한**MMU 설정은 특권명령어로 운영체제만 바꿀 수 있다.**

- **다른 사용자 메모리 또는 운영체제 영역 메모리 접근**

  - usr1 프로그램이 돌면서 usr2프로그램을 건들 때, OS 인터럽트 코드를 바꾸려고하는것(우연히 또는 고의로 다른 사용자 정보/프로그램에 대한 해킹)

  - usr1이 서버의 특정 기능을 수행하고 있을 때 usr2가 이 기능을 쓰려고 할 때 관리를 해줘야 한다.( os한테 부탁해서 )

  

- **해결법**

cpu에서 메모리의 연결은 AddressBus가 있다. (전기줄 다발: 몇번지를 읽겠다.) 이 장소에 접근해서 데이터를 databus(전기줄)을 통해 가져온다. AddressBus를 잘라버린다. 하지만 이는 자기 영역에도 못들어간다.

1. 메모리(OS)에서 CPU에게 이러한 작업을 할 것이다를 전달. 이 작업 돌려서 필요한 정보가 있는 메모리에 접근 요청

1. AddressBus에 문지기를 세운다. 

2. usr1:500번지~550번지 일때, cpu가 요구하는 주소가 이 안에 해당할 때만 접근하게 한다.

3. 문지기 만드는 방법 :Base와 Limit를 둬서 이를 500~550번지로 설정 이 범위를 넘어서면 문지기가 CPU에게 인터럽트를 보낸다.

4. CPU는 이 인터럽트를 받으면 하던 일을 중지하고 OS의 ISR으로 간다.

5. 이 ISR은 이러한 시도를 하는 프로그램을 죽인다.

*** *Segment violation***

***BASE, LIMIT 값은 OS가 준다 (이를 설정하는 것은 특권 명령)***



### CPU보호 (CPU protection)

 **CPU 보호는 한 사용자가 CPU 시간을 독점하는 것을 막는다. CPU 시간을 독점하게 되면 다른 사용자는 프로그램 실행이 불가하므로 Timer를 두어(CPU에) 일정 시간 경과시 타이머 인터럽트를 발생시켜 운영체제가 다른 프로그램으로 강제 전환하는 방법을 취한다.**

- 한 사용자가 실수 또는 고의로 CPU 기잔 독점
  - 예:while(n=1)...
  - 다른 사용자의 프로그램 실행 불가...
- 해결법
  - Timer를 두어 일정 시간 경과시 타이머 인터럽트
  - 인터럽트 -> 운영체제 -> 다른 프로그램으로 강제전환



