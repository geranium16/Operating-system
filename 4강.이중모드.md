# 운영체제 4장 -이중 모드 및 하드웨어 보호 -

> ***: 일반 유저가 특별한 명령을 내리는 것을 막기 위해 크게 I/O, 메모리, CPU를 보호하기 위해 이중 모드를 사용한다. 이 모드를 통해 관리자모드로 OS를 통해야만 하드웨어 접근이 가능하다.***
>
> 컴퓨터를 사용하는 환경은 다양하다. 특정 사람이 특정 컴퓨터만 사용하는 경우도 있겠지만 여러 사람이 동시에 사용하거나 한 사람이 여러 개의 프로그램을 동시에 실행하는 경우 한사람의 고의 또는 실수로 다른 프로그램 전체가 영향을 받을 수 있는 환경이 만들어진다. 예를 들면 **많은 사용자들이 같은 컴퓨터를 사용하고 있는데  서버에 stop(컴퓨터 강제 종료) 명령어 실행하는 프로그램을 갑자기 실행시키녀 모든 사용자가 하던 작업이 종료되어 큰 영향을 끼칠 수 있다.** 이를 막기 위한 보호 장치가 바로 이중 모드다. 이중 모드는 사용자 모드와 관리자 모두로 두 가지 모드를 가지고 있다. **사용자 모드는 단순한 사용자 프로그램을 작동시키는 반면 관리자 모드는 시스템이 내리는 명령어, 프로그램 작동 명령어등 특권 명령어를 내릴 수 있다.**
>
> ***stop: 전체 컴퓨터 시스템 중지***
>
> ***reset: 전체 컴퓨터 시스템을 초기화***
>
> ***In: 키보드.마우스등 입력장치로부터 정보를 받음***
>
> ***Out: 출력장치에 명령 (프린트,디스크, 랜등)***



### *레지스터

컴퓨터는 레지스터 단위로 정보를 주고 받는다. 

레지스터: 비트들의 모음 : 32비트컴퓨터 = 1레지스터에 32개비트

기본 데이터비트 + flag비트  

flag비트: carry(한자리 올라감), negative(음수) 등등….....

 여기에 **모드를 나타내는 플래그가 존재**하는데 0과 1을 값을 통해 사용자 모드(0)인지 관리자 모드(1)인지를 판단한다. 운영체제 서비스가 실행될 때나 하드웨어/소프트웨어 인터럽트가 발생하는 때인 시스템 관련 환경에서는 관리자 모드이고 사용자 프로그램을 실행하는 경우에는 사용자 모드로 존재한다.



### 이중 모드 구동 

1. 인터럽트가 들어오면 OS로 이동하여 사용자모드(0)을 관리자모드(1)로 바꾸고 동작이 완료되면 OS가 관리자모드(1)를 사용자모드(0)으로 바꾸며 유저프로그램으로 돌아온다. 

2. 일반적으로 프로그램을 실행하면 프로그램이 메모리에 적재되는데 사용자 모드에서 실행을 하다가 I/O 관련 명령어가 들어오면 관리자 모드로 들어가 하드웨어 인터럽트를 발생시키게 되고 작업이 끝나면 다시 사용자 모드로 돌아오게 된다. 

3. 또한 운영체제 관련한 명령어가 필요할 경우 다시 관리자 모드로 바뀌어 실행을 시키고 끝날 시 사용자 모드로 돌아온다. 이러한 과정을 거칠 때 운영체제는 특권 명령을 실행시켜도 되는지에 대한 판단을 하고 명령어를 실행시킨다. 만약 특권 명령어를 실행하는 것이 옳지 못한 명령어의 경우 에러 메시지를 보내 실행 할 수 없음을 나타낸다.



***즉, 하나의 프로그램 실행-> 유저프로그램이 실행되다가 하드웨어 인터럽트같은게 들어오면 시스템모드 -> 이 처리가 끝나면 다시 유저 프로그램 -> 시스템모드 ->유저모드 ->시스템모드 반복…***

<img src="/Users/DaeHyeon/Library/Application Support/typora-user-images/스크린샷 2020-02-26 오후 8.04.22.png" alt="스크린샷 2020-02-26 오후 8.04.22" style="zoom:50%;" />

*** *만약, 일반 유저가 특권 명령을 내리면?(고의로)***

 ***cpu가 이 명령을 읽고 모니터비트가 0인지 1인지 확인하여 모니터비트가 0인 경우 잘못된 명령이라 생각하고 내부 인터럽트가 발생시켜 이 특권 명령을 수행하는 대신 미리 올려진 ISR이 실행되며 특권 명령은 사라진다.***





이중 보호는 하드웨어 보호에 큰 역할을 담당하는데 입출력 장치 보호, 메모리 보호, CPU 보호 이렇게 세 가지로 나눌 수 있다.

1. 입출력 장치 보호 (Input/Output device protection)
2. 메모리 보호 (Memory protection)
3. CPU 보호 (CPU protection)



### 입출력 장치 보호 (Input/Output device protection)

 사용자의 잘못된 입출력 명령어를 제어한다. 다른 사용자와 동시 사용하는 것을 막기 위해 입출력 명령을 특권 명령어로 하여 IN, OUT 이라는 명령어가 존재한다. 입출력 장치를 사용하기 위해서는 운영체제에 입출력을 하고 싶다는 것을 요청하고 관리자 모드로 운영체제가 입출력을 실행시켜주면 일이 끝난 후 사용자 모드로 돌아오게 된다. 만약 다른 사용자가 사용할 경우 올바른 요청이 아니므로 운영체제가 거부를 하게 된다.

1. 다른 사용자의 입출력,정보등에 방해 (프린트 혼선, 리셋등)

: 1번 사용자가 프린트하고 있는데 2번 사용자가 프린트하려고 하는 경우

2. 다른 사람의 파일 읽고 쓰기 (하드디스크)

: A가 사용하는 하드디스크파일이 있는데 B가 읽으려고 하는 경우

**해결법**

- 입출력 명령을 특권명령으로 IN,OUT
- 입출력을 하려면 운영체제에게 요청하고 (System mode 전환)

게임 중(유저모드) IN,OUT명령 불가능하게 되고 IN,OUT을 하려면 소프트웨어인터럽트에 의해(INT명령) OS에 부탁해 SystemMode로 변경  후 OS에서 이에 해당하는 ISR 실행 (사용자 -> OS ->사용자)



예제) A가 사용하는 하드디스크파일이 있는데 B가 읽으려고한다.

1. OS한테 부탁한다. 이 하드디스크를 읽고 싶다고 (소프트웨어인터럽트)
2. OS 왈: 넌 B 인데 A 읽을 수 없어: 거부

*** *Privileged Instruction vilolation***

### 메모리 보호 (Memory protection)

 메모리 보호를 위한 역할은 다른 사용자가 메모리 또는 운영체제 영역 메모리를 접근할 경우를 막기 위한 작업이다. 특히 해킹에 관련된 부분이 많이 작용을 한다. 이를 제어하기 위해 **MMU(Memory Management Unit)**를 두어 다른 메모리 영역 침범하는 것을 감시하는 장치를 놓는다. MMU는 각 사용자마다 할당 받을 수 있는 메모리 공간의 영역을 정하여 다른 사용자는 침범을 할 수 없게 만든다. 이러한 설정은 특권명령어로 운영체제만 바꿀 수 있다.

1. usr1 프로그램이 돌면서 usr2프로그램을 건들 때, OS 인터럽트 코드를 바꾸려고하는것(우연히 또는 고의로 다른 사용자 정보/프로그램에 대한 해킹)

2. 운영 체제 해킹



**해결법**

cpu에서 메모리의 연결은 AddressBus가 있다. (전기줄 다발: 몇번지를 읽겠다.) 이 장소에 접근해서 데이터를 databus(전기줄)을 통해 가져온다. AddressBus를 잘라버린다. 하지만 이는 자기 영역에도 못들어간다.

1. AddressBus에 문지기를 세운다. 

2. usr1:500번지~550번지 일때, cpu가 요구하는 주소가 이 안에 해당할 때만 접근하게 한다.

3. 문지기 만드는 방법 :Base와 Limit를 둬서 이를 500~550번지로 설정 이 범위를 넘어서면 문지기가 CPU에게 인터럽트를 보낸다.

4. CPU는 이 인터럽트를 받으면 하던 일을 중지하고 OS의 ISR으로 간다.

5. 이 ISR은 이러한 시도를 하는 프로그램을 죽인다.

***Segment violation***

***BASE, LIMIT 값은 OS가 설정 (이를 설정하는 것은 특권 명령)***



### 정리

**이중 모드 : 일반유저들은 하드웨어, CPU에 직접 접근 불가능하게 만들고 OS를 거쳐 관리자모드로 접근하게 만드는 보호의 기능**

