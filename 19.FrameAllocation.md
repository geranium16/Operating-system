#  [운영체제] 19. Frame Allocation (프레임할당)

## 1. Global VS Local Replacement

- Global Replacement

 메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.

페이지 교체의 대상이 메인 메모리에 있는 모든 페이지를 대상으로 한다.

다른 프로세스의 영향을 받게 되게 된다. 프로세스의 실행이 늦어지거나 빨라질 수 있다.

개별 프로세스의 동작 보다는 시스템 전반의 효율에 중점을 두기 때문에 대형 시스템에서 이용된다.

- Local Replacement

메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.

각 프로세스에 할당된 프레임의 수는 변하지 않으며, 프로세스의 상대적인 중요도에 따라 메모리 할당을 조정, 성능개선을 할 수 있다.

즉, Local은 P1은 P1의 페이지끼리만, P2는 P2 페이지끼리만 교체 작업을 수행하고 Global은 P1 페이지를 빼고 P2 페이지를 넣을 수도 있다.

메모리 사용 효율은 일반적으로 Global Replacement가 좋다.



## 2. 프레임 할당(Allocation of Frames)

### 2.1. Thrashing(쓰레싱)

일반적으로 메모리에 올라가는 프로세스 개수(페이지 개수x)가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 프로세스가 1개일 때는 해당 프로세스가 I/O를 만나면 할 일이 없다. 따라서 프로세스가 많을수록 CPU의 할 일 증가한다. 하지만 이는 일정 범위까지는 맞는 예상이지만, 그 **범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상**이 나타난다.


![img](https://user-images.githubusercontent.com/34755287/70577700-19128800-1bef-11ea-8322-0f6e67d6334d.png)

위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득차게 된다. 그 후에도 계속 프로세스가 증가한다면 **메모리와 backing store 사이에 page in/out 작업**이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.

***즉, 프로세스가 적당히 있을 때는 프로세스가 사용하는 페이지를 충분히 올릴 수 있어 page in/out 작업이 많이 발생하지 않아 CPU 효율이 좋았다. 하지만 프로세스가 많을 때는 프로세스들이 사용하는 페이지를 충분히 올리지 못해 Page Fault가 자주 발생하고 효율이 떨어진다.***

쓰레싱을 해결하는 방법

Global Replacement보다 Local Replacement를 사용하는 것이다. 프로세스 당 충분한 수의 메모리를 할당하는 것이 Thrashing을 줄일 수 있다. 하지만 메모리 사용 효율이 떨어지는 단점이 있다.

***그렇다면, 적절한 프레임의 수는 어떻게 정하는것일까?***

- Static Allocation
  - Equal Allocation: 모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다. 프레임이 많이 필요한 프로세스와 조금 필요한 프로세스의 프레임 수가 같다면 비효율적
  - 비례 할당(Proportional Allocation): 프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.

이처럼 정적 할당은 한계가 뚜렷하다. 이를 해결하기 위한 방법은 **실행 중에 프레임을 할당하는 동적 할당**이다.

### 2.2. 동적 할당(Dynamic Allocation)

#### 2.2.1. Working Set Model

프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 **Locality** 성질이 성립한다는 것을 발견할 수 있었다.

![img](https://user-images.githubusercontent.com/34755287/70577701-19128800-1bef-11ea-88f7-f75e6b65e063.png)

위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.

이 방법 역시 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.

이를 해결하기 위해 나온 것이 **working set** 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.

![img](https://user-images.githubusercontent.com/34755287/70577702-19ab1e80-1bef-11ea-92e2-35ce8154df64.png)

위 그림은 working set을 사용하는 모습이다. working set은 **현재 시간에서 일정 시간(△) 이전동안 사용되었던 페이지의 집합**이다. △(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 **working set window** 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.

만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.

### 2.3. Page-Fault Frequency(PFF)

페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.

![img](https://user-images.githubusercontent.com/34755287/70577703-19ab1e80-1bef-11ea-9b8c-0d3b37805bda.png)

위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 **상한선(upper bound)과 하한선(lower bound)를 설정**한다.

만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.

## 3. 페이지 크기

현재 페이지의 일반적인 크기는 **4KB ~ 4MB** 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.

페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.

- **내부단편화**: 내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.
- **Page-in, page-out 시간**: 페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(**seek time**) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)
- **페이지 테이블 크기**: 페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.
- **Memory resolution(해상도)**: Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.
- **Page fault 발생 확률**: Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.

## Reference

- [운영체제 KOCW 양희재 교수님 강의](http://www.kocw.net/home/search/kemView.do?kemId=978503)
- [Operation System Concepts 9th](http://www.kyobobook.co.kr/product/detailViewEng.laf?ejkGb=ENG&mallGb=ENG&barcode=9781118093757&orderClick=LAG&Kc=)

- [SUNGBUM PARK 블로그](https://velog.io/@codemcd/운영체제OS-15.-가상메모리)



